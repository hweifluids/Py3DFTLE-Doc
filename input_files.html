

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The nekRS Input Files &mdash; PyFTLE3D 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Commonly-Used Variables in nekRS" href="commonly_used_variables.html" />
    <link rel="prev" title="Theory" href="theory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyFTLE3D
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="theory.html">Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The nekRS Input Files</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#parameter-file-par">Parameter File (.par)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#boomeramg-section"><code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-section"><code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-keys">Common keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mesh-section"><code class="docutils literal notranslate"><span class="pre">MESH</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#occa-section"><code class="docutils literal notranslate"><span class="pre">OCCA</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pressure-section"><code class="docutils literal notranslate"><span class="pre">PRESSURE</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problemtype-section"><code class="docutils literal notranslate"><span class="pre">PROBLEMTYPE</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalarxx-section"><code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#temperature-section"><code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#velocity-section"><code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casedata-section"><code class="docutils literal notranslate"><span class="pre">CASEDATA</span></code> section</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deprecated-parameters">Deprecated parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-option-rea">Legacy Option (.rea)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mesh-file-re2">Mesh File (.re2)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#converting-an-existing-commercial-mesh">Converting an Existing Commercial Mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nek5000-script-based-meshing">Nek5000 Script-Based Meshing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Legacy Option (.rea)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#user-defined-host-functions-udf">User-Defined Host Functions (.udf)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#udf-executestep-nrs-t-nrs-dfloat-time-int-tstep"><code class="docutils literal notranslate"><span class="pre">UDF_ExecuteStep(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">dfloat</span> <span class="pre">time,</span> <span class="pre">int</span> <span class="pre">tstep)</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#udf-loadkernels-nrs-t-nrs"><code class="docutils literal notranslate"><span class="pre">UDF_LoadKernels(nrs_t*</span>&#160; <span class="pre">nrs)</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#udf-setup0-mpi-comm-comm-setupaide-options"><code class="docutils literal notranslate"><span class="pre">UDF_Setup0(MPI_Comm</span> <span class="pre">comm,</span> <span class="pre">setupAide</span> <span class="pre">&amp;</span> <span class="pre">options)</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#udf-setup-nrs-t-nrs"><code class="docutils literal notranslate"><span class="pre">UDF_Setup(nrs_t*</span> <span class="pre">nrs)</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-functions-for-custom-sources-on-the-udf-structure">Other Functions for Custom Sources on the <code class="docutils literal notranslate"><span class="pre">udf</span></code> Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#legacy-option-usr">Legacy Option (.usr)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#user-defined-device-functions-oudf">User-Defined Device Functions (.oudf)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#boundary-condition-functions">Boundary Condition Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="commonly_used_variables.html">Commonly-Used Variables in nekRS</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling.html">Compiling nekRS</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="detailed_usage.html">FAQs</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="just_in_time_compilation.html">Just-in-time Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="doxygen.html">Doxygen</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyFTLE3D</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The nekRS Input Files</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/input_files.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-nekrs-input-files">
<span id="input"></span><h1>The nekRS Input Files<a class="headerlink" href="#the-nekrs-input-files" title="Link to this heading"></a></h1>
<p>This page describes the input file structure and syntax needed to run a nekRS simulation.
A nekRS simulation is referred to as a “case,” and at a minimum requires four files to run -</p>
<ul class="simple">
<li><p>Parameter file, with <code class="docutils literal notranslate"><span class="pre">.par</span></code> extension</p></li>
<li><p>Mesh file, with <code class="docutils literal notranslate"><span class="pre">.re2</span></code> extension</p></li>
<li><p>User-defined functions for the host, with <code class="docutils literal notranslate"><span class="pre">.udf</span></code> extension</p></li>
<li><p>User-defined functions for the device, with <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> extension</p></li>
</ul>
<p>The “case name” is then the common prefix applied to these files - for instance,
a complete input description with a case name of “eddy” would be given by the files
<code class="docutils literal notranslate"><span class="pre">eddy.par</span></code>, <code class="docutils literal notranslate"><span class="pre">eddy.re2</span></code>, <code class="docutils literal notranslate"><span class="pre">eddy.udf</span></code>, and <code class="docutils literal notranslate"><span class="pre">eddy.oudf</span></code>.
The only restrictions on the case name are:</p>
<ul class="simple">
<li><p>It must be used as the prefix on all simulation files, and</p></li>
<li><p>Typical restrictions for naming files for your operating system</p></li>
</ul>
<p>The next four sections describe the structure and syntax for each of these four files
for a general case.
Because the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a> code is a predecessor to
nekRS, some aspects of the current nekRS input file design are selected to enable faster translation of
Nek5000 input files into nekRS input files. Because these
Nek5000-based approaches require proficiency in Fortran, the inclusion of several additional input
files, and in some cases, careful usage of fixed-format text inputs, all
Nek5000-based methods for case setup are referred to here as “legacy” approaches.
All new users are encouraged to adopt the nekRS-based problem setup.</p>
<p>The scope of this page is merely to introduce the format and purpose of the four
files needed to set up a nekRS simulation. Much more detailed instructions are provided
on the <a class="reference internal" href="detailed_usage.html#detailed"><span class="std std-ref">FAQs</span></a> page.</p>
<section id="parameter-file-par">
<h2>Parameter File (.par)<a class="headerlink" href="#parameter-file-par" title="Link to this heading"></a></h2>
<p>Most information about the problem setup is defined in the parameter file. This file is organized
in a number of sections, each with a number of keys. Values are assigned to these keys in order to
control the simulation settings.</p>
<p>The general structure of the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file is as
follows, where <code class="docutils literal notranslate"><span class="pre">FOO</span></code> and <code class="docutils literal notranslate"><span class="pre">BAR</span></code> are both section names, with a number of (key, value) pairs.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[FOO]</span>
<span class="w">  </span><span class="na">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">value</span>
<span class="w">  </span><span class="na">baz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">bat</span>

<span class="k">[BAR]</span>
<span class="w">  </span><span class="na">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">beta</span>
<span class="w">  </span><span class="na">gamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">delta + keyword=value + ...</span>
</pre></div>
</div>
<p>The valid sections for setting up a nekRS simulation are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span></code>: settings for the (optional) <a class="reference internal" href="glossary.html#term-AMG"><span class="xref std std-term">AMG</span></a> solver</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GENERAL</span></code>: generic settings for the simulation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MESH</span></code>: settings for the mesh</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OCCA</span></code>: backend <a class="reference internal" href="glossary.html#term-OCCA"><span class="xref std std-term">OCCA</span></a> device settings</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PRESSURE</span></code>: settings for the pressure solution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PROBLEMTYPE</span></code>: settings for the governing equations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code>: settings for the <code class="docutils literal notranslate"><span class="pre">XX</span></code>-th scalar</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code>: settings for the temperature solution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>: settings for the velocity solution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CASEDATA</span></code>: custom settings</p></li>
</ul>
<p>Each of the keys and value types are now described for these sections. The
formatting used here to describe valid key, value combinations is as follows.
Take the <code class="docutils literal notranslate"><span class="pre">backend</span></code> key in the <code class="docutils literal notranslate"><span class="pre">OCCA</span></code> section as an example:</p>
<p><strong>backend</strong> <em>(CUDA), CPU, HIP, OPENCL, OPENMP, SERIAL</em> [<code class="docutils literal notranslate"><span class="pre">THREAD</span> <span class="pre">MODEL</span></code>]</p>
<p>Here, <code class="docutils literal notranslate"><span class="pre">backend</span></code> is the key, and <code class="docutils literal notranslate"><span class="pre">CUDA</span></code>, <code class="docutils literal notranslate"><span class="pre">CPU</span></code>, <code class="docutils literal notranslate"><span class="pre">HIP</span></code>, <code class="docutils literal notranslate"><span class="pre">OPENCL</span></code>, <code class="docutils literal notranslate"><span class="pre">OPENMP</span></code>,
and <code class="docutils literal notranslate"><span class="pre">SERIAL</span></code> are all valid values. Defaults are indicated in parentheses - therefore,
if you do not explicitly give the <code class="docutils literal notranslate"><span class="pre">backend</span></code> in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file,
the <a class="reference internal" href="glossary.html#term-CUDA"><span class="xref std std-term">CUDA</span></a> backend is used. Similar conventions are used to describe non-character
type values; for instance, <em>(3), &lt;int&gt;</em> indicates that the default value for the indicated
key is 3, but any integer value can be provided.</p>
<p>Most of the values associated with the various keys in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file are read by nekRS
and then saved to various arguments in the <code class="docutils literal notranslate"><span class="pre">options</span></code> data structure. The argument
is indicated in this section within square brackets. For example,
the value set by the <code class="docutils literal notranslate"><span class="pre">backend</span></code> key is stored in the <code class="docutils literal notranslate"><span class="pre">THREAD</span> <span class="pre">MODEL</span></code> argument
to <code class="docutils literal notranslate"><span class="pre">options</span></code>. In other words, if you wanted to grab the value set by the user for the
<code class="docutils literal notranslate"><span class="pre">backend</span></code> key, and save it in a local variable named <code class="docutils literal notranslate"><span class="pre">user_occa_backend</span></code>,
you can use the <code class="docutils literal notranslate"><span class="pre">getArgs</span></code> function on the <code class="docutils literal notranslate"><span class="pre">options</span></code> data structure as follows.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">user_occa_backend</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">getArgs</span><span class="p">(</span><span class="s">&quot;THREAD MODEL&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">user_occa_backend</span><span class="p">);</span>
</pre></div>
</div>
<p>In other words, if you have <code class="docutils literal notranslate"><span class="pre">backend</span> <span class="pre">=</span> <span class="pre">CUDA</span></code> in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file, then
<code class="docutils literal notranslate"><span class="pre">user_occa_backend</span></code> would be set to <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> in the above code.</p>
<p>Generally, most <code class="docutils literal notranslate"><span class="pre">.par</span></code> settings are not saved to a data structure, so throughout the code
base, whenever information from the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file is needed, it is simply
extracted on-the-fly via the <code class="docutils literal notranslate"><span class="pre">options</span></code> structure.</p>
<p>nekRS performs validation of the par file. Invalid sections, invalid keys or values,
invalid value combinations, missing values etc. will terminate the NekRS run with a
clear error message. Deprecated attributes will be highlighted.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This user guide may quickly become out of date unless developers are careful to keep
the keys listed here up to date. A list of possible values is also given in
<code class="docutils literal notranslate"><span class="pre">doc/parHelp.txt</span></code></p>
</div>
<p>nekRS uses just-in-time compilation to allow the incorporation of user-defined functions
into program execution. These functions can be written to allow ultimate flexibility on
the part of the user to affect the simulation, such as to define custom fluid properties,
specify spatially-dependent boundary and initial conditions, and apply post-processing
operations. Some of the parameters in the sections can be overridden through the use of
user-defined functions - see, for example, the <code class="docutils literal notranslate"><span class="pre">viscosity</span></code> key in
the <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code> section. This parameter is used to set a constant viscosity, whereas
for variable-property simulations, a user-defined function will override the <code class="docutils literal notranslate"><span class="pre">viscosity</span></code>
input parameter. A full description of these user-defined functions on the host and
device are described in Sections <a class="reference internal" href="#udf-functions"><span class="std std-ref">UDF Functions</span></a> and
<a class="reference internal" href="#oudf-functions"><span class="std std-ref">OUDF Functions</span></a>. So, the description of valid (key, value)
pairs here does not necessarily imply that these parameters reflect the full capabilities
of nekRS.</p>
<section id="boomeramg-section">
<h3><code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span></code> section<a class="headerlink" href="#boomeramg-section" title="Link to this heading"></a></h3>
<p>This section is used to describe settings for the (optional) <a class="reference internal" href="glossary.html#term-AMG"><span class="xref std std-term">AMG</span></a> solver.</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>coarsenType</strong> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">COARSEN</span> <span class="pre">TYPE</span></code>]</p></li>
<li><p><strong>interpolationType</strong> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">INTERPOLATION</span> <span class="pre">TYPE</span></code>]</p></li>
<li><p><strong>iterations</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">ITERATIONS</span></code>]</p></li>
<li><p><strong>nonGalerkinTol</strong> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">NONGALERKIN</span> <span class="pre">TOLERANCE</span></code>]</p></li>
<li><p><strong>smootherType</strong> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">SMOOTHER</span> <span class="pre">TYPE</span></code>]</p></li>
<li><p><strong>strongThreshold</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">BOOMERAMG</span> <span class="pre">NONGALERKIN</span> <span class="pre">TOLERANCE</span></code>]</p></li>
</ul>
</div></blockquote>
</section>
<section id="general-section">
<h3><code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section<a class="headerlink" href="#general-section" title="Link to this heading"></a></h3>
<p>This section is used to describe generic settings for the simulation such as time steppers,
solution order, and file writing control.</p>
<ul>
<li><p><strong>constFlowRate</strong> <em>&lt;string&gt;</em> [<code class="docutils literal notranslate"><span class="pre">&quot;CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">RATE</span> <span class="pre">=</span> <span class="pre">[value</span> <span class="pre">is</span> <span class="pre">provided]</span></code>]</p>
<p>Set a constant flow rate in a given direction. Either <code class="docutils literal notranslate"><span class="pre">meanVelocity</span></code> or
<code class="docutils literal notranslate"><span class="pre">meanVolumetricFlow</span></code> must be provided to set the flow rate,
and either <code class="docutils literal notranslate"><span class="pre">bid</span></code> or <code class="docutils literal notranslate"><span class="pre">direction</span></code> must be provided to set the direction.
The following options are valid:</p>
<ul>
<li><p><strong>meanVelocity</strong> <em>&lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">RATE</span> <span class="pre">TYPE</span> <span class="pre">=</span> <span class="pre">BULK</span></code>, <code class="docutils literal notranslate"><span class="pre">FLOW</span> <span class="pre">RATE</span></code>]</p>
<p>Sets the mean velocity.</p>
</li>
<li><p><strong>meanVelocity</strong> <em>&lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">RATE</span> <span class="pre">TYPE</span> <span class="pre">=</span> <span class="pre">VOLUMETRIC</span></code>, <code class="docutils literal notranslate"><span class="pre">FLOW</span> <span class="pre">RATE</span></code>]</p>
<p>Sets the mean volumetric flow rate.</p>
</li>
<li><p><strong>bid</strong> <em>&lt;int&gt;, &lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">FROM</span> <span class="pre">BID</span></code>, <code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">TO</span> <span class="pre">BID</span></code>]</p>
<p>Sets the flow direction based on two boundary IDs.</p>
</li>
<li><p><strong>direction</strong> <em>x, y, z</em>  [<code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">FLOW</span> <span class="pre">DIRECTION</span></code>]</p>
<p>Sets a flow direction parallel to the global coordinate axis.</p>
</li>
</ul>
</li>
<li><p><strong>cubaturePolynomialOrder</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">CUBATURE</span> <span class="pre">POLYNOMIAL</span> <span class="pre">DEGREE</span></code>]</p>
<p>Polynomial order for the cubature. If not specified, this defaults to the integer
closest to <span class="math notranslate nohighlight">\(\frac{3}{2}(N + 1)\)</span> minus one, where <span class="math notranslate nohighlight">\(N\)</span> is the polynomial
order.</p>
</li>
<li><p><strong>dealiasing</strong> <em>(true), false</em></p>
<p>If dealiasing is turned on, [<code class="docutils literal notranslate"><span class="pre">ADVECTION</span> <span class="pre">TYPE</span></code>] is set to <code class="docutils literal notranslate"><span class="pre">CUBATURE+CONVECTIVE</span></code>,
whereas if dealiasing is turned off, [<code class="docutils literal notranslate"><span class="pre">ADVECTION</span> <span class="pre">TYPE</span></code>] is set to <code class="docutils literal notranslate"><span class="pre">CUBATURE</span></code>.</p>
</li>
<li><p><strong>dt</strong> <em>&lt;string&gt;</em> [<code class="docutils literal notranslate"><span class="pre">DT</span></code>]</p>
<p>Time step size. If any of the keyword options <code class="docutils literal notranslate"><span class="pre">targetCFL</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> or <code class="docutils literal notranslate"><span class="pre">initial</span></code>
are specified (separated by <code class="docutils literal notranslate"><span class="pre">+</span></code>), a variable timestep [<code class="docutils literal notranslate"><span class="pre">VARIABLE</span> <span class="pre">DT</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>]
is used. Otherwise, <code class="docutils literal notranslate"><span class="pre">dt</span></code> is parsed as <code class="docutils literal notranslate"><span class="pre">float</span></code> and indicates the time step size.</p>
<p>The following keywords may be given:</p>
<ul class="simple">
<li><p><strong>targetCFL</strong> <em>(0.5), &lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">TARGET</span> <span class="pre">CFL</span></code>]: The target <a class="reference internal" href="glossary.html#term-CFL"><span class="xref std std-term">CFL</span></a> is also
used to set a default for the <code class="docutils literal notranslate"><span class="pre">subCyclingSteps</span></code>. If not specified, it is given
by <cite>max(subcyclingSteps*2, 0.5)`</cite>.</p></li>
<li><p><strong>max</strong> <em>(0), &lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">MAX</span> <span class="pre">DT</span></code>]: Largest allowed timestep. If 0 or unset, the
option is ignored.</p></li>
<li><p><strong>initial</strong> <em>(0), &lt;float&gt;</em> [initially written to <code class="docutils literal notranslate"><span class="pre">DT</span></code>]: initial timestep.</p></li>
</ul>
</li>
<li><p><strong>elapsedTime</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">STOP</span> <span class="pre">AT</span> <span class="pre">ELAPSED</span> <span class="pre">TIME</span></code>]</p>
<p>Elapsed time at which to end the simulation, if using <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">elapsedTime</span></code>.</p>
</li>
<li><p><strong>endTime</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">END</span> <span class="pre">TIME</span></code>]</p>
<p>Final time at which to end the simulation, if using <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">endTime</span></code>.</p>
</li>
<li><p><strong>numSteps</strong> <em>(0), &lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">NUMBER</span> <span class="pre">TIMESTEPS</span></code>]</p>
<p>Number of time steps to perform, if using <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">numSteps</span></code>. By default, if not
specified, then it is assumed that no time steps are performed.</p>
</li>
<li><p><strong>oudf</strong> <em>[casename].oudf</em> [<code class="docutils literal notranslate"><span class="pre">UDF</span> <span class="pre">OKL</span> <span class="pre">FILE</span></code>]</p>
<p>File name (including extension) of the <code class="docutils literal notranslate"><span class="pre">*.oudf</span></code> file, relative to the current directory.
By default, the stem of the <code class="docutils literal notranslate"><span class="pre">*.par</span></code> file is used as <code class="docutils literal notranslate"><span class="pre">casename</span></code>.</p>
</li>
<li><p><strong>polynomialOrder</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">POLYNOMIAL</span> <span class="pre">DEGREE</span></code>]</p>
<p>Polynomial order for the spectral element solution. An order of <span class="math notranslate nohighlight">\(N\)</span> will result
in <span class="math notranslate nohighlight">\(N+1\)</span> basis functions for each spatial dimension. The polynomial order is
currently limited to <span class="math notranslate nohighlight">\(N &lt; 10\)</span>.</p>
</li>
<li><p><strong>startFrom</strong> <em>&lt;string&gt;</em> [<code class="docutils literal notranslate"><span class="pre">RESTART</span> <span class="pre">FILE</span> <span class="pre">NAME</span></code>]</p>
<p>Absolute or relative path to a nekRS output file from which to start the simulation from.
When used, the [<code class="docutils literal notranslate"><span class="pre">RESTART</span> <span class="pre">FROM</span> <span class="pre">FILE</span></code>] option argument is also set to true.
If the solution in the restart file was obtained with a different polynomial order,
interpolation is performed to the current simulation settings. To only read select fields
from the restart file (such as if you wanted to only apply the temperature solution from the
restart file to the present simulation), append <code class="docutils literal notranslate"><span class="pre">+U</span></code> (to read velocity), <code class="docutils literal notranslate"><span class="pre">+P</span></code> (to read pressure),
or <code class="docutils literal notranslate"><span class="pre">+T</span></code> (to read temperature) to the end of the restart file name. For instance, if the restart
file is named <code class="docutils literal notranslate"><span class="pre">restart.fld</span></code>, using <code class="docutils literal notranslate"><span class="pre">restart.fld+T</span></code> will only read the temperature solution.
If <code class="docutils literal notranslate"><span class="pre">startFrom</span></code> is omitted, the simulation is assumed to start based on the user-defined initial conditions at time zero.</p>
</li>
<li><p><strong>stopAt</strong> <em>(numSteps), elapsedTime, endTime</em></p>
<p>When to stop the simulation, either based on a number of time steps <em>numSteps</em>, a simulated
end time <em>endTime</em>, or a total elapsed wall time <em>elapsedTime</em>. If <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">numSteps</span></code>,
the <code class="docutils literal notranslate"><span class="pre">numSteps</span></code> parameter must be provided. If <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">endTime</span></code>, the <code class="docutils literal notranslate"><span class="pre">endTime</span></code>
parameter must be provided. If <code class="docutils literal notranslate"><span class="pre">stopAt</span> <span class="pre">=</span> <span class="pre">elapsedTime</span></code>, the <code class="docutils literal notranslate"><span class="pre">elapsedTime</span></code> parameter
must be provided.</p>
</li>
<li><p><strong>subCyclingSteps</strong> <em>(0), &lt;int&gt;, auto</em> [<code class="docutils literal notranslate"><span class="pre">SUBCYCLING</span> <span class="pre">STEPS</span></code>]</p>
<p>Number of subcycling steps; if <code class="docutils literal notranslate"><span class="pre">dt:</span> <span class="pre">targetCFL</span></code> is specified, the number of subcycling
steps is taken as the integer nearest to half the target <a class="reference internal" href="glossary.html#term-CFL"><span class="xref std std-term">CFL</span></a> as given by
the <code class="docutils literal notranslate"><span class="pre">dt:</span> <span class="pre">targetCFL</span></code> parameter. In this case, <code class="docutils literal notranslate"><span class="pre">auto</span></code> ensures that an error is raised
if <code class="docutils literal notranslate"><span class="pre">dt:</span> <span class="pre">targetCFL</span></code> is not specified.</p>
</li>
<li><p><strong>timeStepper</strong> <em>(tombo2), bdf1, bdf2, bdf3, tombo1, tombo3</em> [<code class="docutils literal notranslate"><span class="pre">TIME</span> <span class="pre">INTEGRATOR</span></code>]</p>
<p>The method to use for time stepping. Note that
if you select any of the <a class="reference internal" href="glossary.html#term-BDF"><span class="xref std std-term">BDF</span></a> options, the time integrator is internally set to
the <span class="xref std std-term">TOMBO</span> time integrator of equivalent order.</p>
</li>
<li><p><strong>udf</strong> <em>[casename].udf</em> [<code class="docutils literal notranslate"><span class="pre">UDF</span> <span class="pre">FILE</span></code>]</p>
<p>File name (including extension) of the <code class="docutils literal notranslate"><span class="pre">*.udf</span></code> file, relative to the current directory.
By default, the stem of the <code class="docutils literal notranslate"><span class="pre">*.par</span></code> file is used as <code class="docutils literal notranslate"><span class="pre">casename</span></code>.</p>
</li>
<li><p><strong>usr</strong> <em>[casename].usr</em> [<code class="docutils literal notranslate"><span class="pre">NEK</span> <span class="pre">USR</span> <span class="pre">FILE</span></code>]</p>
<p>File name (including extension) of the <code class="docutils literal notranslate"><span class="pre">*.usr</span></code> file, relative to the current directory.
By default, the stem of the <code class="docutils literal notranslate"><span class="pre">*.par</span></code> file is used as <code class="docutils literal notranslate"><span class="pre">casename</span></code>.</p>
</li>
<li><p><strong>verbose</strong> <em>(false), true</em> [<code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>]</p>
<p>Whether to print the simulation results in verbose format to the screen.</p>
</li>
<li><p><strong>writeControl</strong> <em>(timeStep), runTime</em> [<code class="docutils literal notranslate"><span class="pre">SOLUTION</span> <span class="pre">OUTPUT</span> <span class="pre">COTROL</span></code>]</p>
<p>Method to use for the writing of output files, either based on a time step interval with
<em>timeStep</em> (in which case <code class="docutils literal notranslate"><span class="pre">SOLUTION</span> <span class="pre">OUTPUT</span> <span class="pre">CONTROL</span></code> is set to <code class="docutils literal notranslate"><span class="pre">STEPS</span></code>)
or a simulated time interval with <em>runTime</em> (in which case <code class="docutils literal notranslate"><span class="pre">SOLUTION</span> <span class="pre">OUTPUT</span> <span class="pre">CONTROL</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">RUNTIME</span></code>).</p>
</li>
<li><p><strong>writeInterval</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SOLUTION</span> <span class="pre">OUTPUT</span> <span class="pre">INTERVAL</span></code>]</p>
<p>Output writing frequency, either in units of time steps for <code class="docutils literal notranslate"><span class="pre">writeControl</span> <span class="pre">=</span> <span class="pre">timeStep</span></code> or
in units of simulation time for <code class="docutils literal notranslate"><span class="pre">writeControl</span> <span class="pre">=</span> <span class="pre">runTime</span></code>. If a runtime step control is
used that does not perfectly align with the time steps of the simulation, nekRS will write
an output file on the timestep that most closely matches the desired write interval.</p>
</li>
</ul>
</section>
<section id="common-keys">
<h3>Common keys<a class="headerlink" href="#common-keys" title="Link to this heading"></a></h3>
<p>These parameters may be specified in any of the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code>, <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>, <code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> and
<code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code>  sections. If the parameter is not specified in any given <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>,
<code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> or <code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code> section, its values are usually inherited from the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code>
section.</p>
<p>The key for the <code class="docutils literal notranslate"><span class="pre">options</span></code> structure listed here is the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> key; in the other sections,
the key is prefixed with the section name.</p>
<ul>
<li><p><strong>regularization</strong> <em>(“none”), &lt;string&gt;</em> [<code class="docutils literal notranslate"><span class="pre">REGULARIZATION</span> <span class="pre">METHOD</span></code>]</p>
<p>Filtering settings., options are separated by <code class="docutils literal notranslate"><span class="pre">+</span></code>. This parameter is mutually exclusive
with the (deprecated) <code class="docutils literal notranslate"><span class="pre">filtering</span></code> parameter. The parameter may be specified in any of
the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code>, <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>, <code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> and <code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code>  sections. If the parameter
is no specified in any given <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>, <code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> or <code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code> section,
its values are inherited from the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section.</p>
<p>Filtering is analogous to Nek5000; the <code class="docutils literal notranslate"><span class="pre">hpfrt</span></code> filter is described  further in the
<a class="reference external" href="http://nek5000.github.io/NekDoc/problem_setup/filter.html#high-pass-filter">Nek5000 documentation</a>.</p>
<p>The following examples for <code class="docutils literal notranslate"><span class="pre">regularization</span></code> are given in <code class="docutils literal notranslate"><span class="pre">examples</span></code>:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># examples/turbPipePeriodic</span>
<span class="na">regularization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">hpfrt + nModes=1 + scalingCoeff=10</span>

<span class="c1"># examples/double_shear</span>
<span class="na">regularization</span><span class="o">=</span><span class="s">avm+c0+highestModalDecay+scalingCoeff=0.5+rampconstant=1</span>
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">none</span></code>: regularization is disabled.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hpfrt</span></code>: High-pass filter. The following settings apply to this mode:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">nmodes</span></code> <em>(1), &lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">HPFRT</span> <span class="pre">MODES</span></code>]</p>
<p>Number of filtered modes <span class="math notranslate nohighlight">\((N-N')\)</span>, where <span class="math notranslate nohighlight">\((N)\)</span> is the
polynomial degree and <span class="math notranslate nohighlight">\((N')\)</span> the number of fully resolved modes.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cutoffratio</span></code> <em>&lt;float&gt;</em></p>
<p>Alternatively, the number of filtered modes can be given
by the cutoff ratio, where <span class="math notranslate nohighlight">\(\frac{N'+1}{N+1} = {\tt filterCutoffRatio}\)</span>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">scalingcoeff</span></code> <em>(1.0), &lt;expression&gt;</em> (required): [<code class="docutils literal notranslate"><span class="pre">HPFRT</span> <span class="pre">STRENGTH</span></code>]</p>
<p>filter weight</p>
<blockquote>
<div></div></blockquote>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">avm+hpfResidual</span></code>: use HPF Residual <a class="reference internal" href="glossary.html#term-AVM"><span class="xref std std-term">AVM</span></a>, or <code class="docutils literal notranslate"><span class="pre">avm+highestModalDecay</span></code>:
use Persson’s highest modal decay AVM.
The AVM is described in <a class="reference internal" href="references.html#persson" id="id1"><span>[Persson]</span></a>, and only allowed for scalars.
If specified in <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code>, the <code class="docutils literal notranslate"><span class="pre">regularization</span></code> parameter must be overwritten in the
<code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code> section. The following settings apply to these modes:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">scalingcoeff</span></code> <em>(1.0), &lt;expression&gt;</em> (required) [<code class="docutils literal notranslate"><span class="pre">REGULARIZATION</span> <span class="pre">SCALING</span> <span class="pre">COEFF</span></code>]</p>
<p>filter weight</p>
</li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">nmodes</span></code>, <code class="docutils literal notranslate"><span class="pre">cutoffratio</span></code> and <code class="docutils literal notranslate"><span class="pre">scalingcoeff</span></code> parameters described above. With
<code class="docutils literal notranslate"><span class="pre">HighestModalDecay</span></code> mode, <code class="docutils literal notranslate"><span class="pre">scalingcoeff</span></code> is interpreted (and overwrites) as
<code class="docutils literal notranslate"><span class="pre">vismaxcoeff</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vismaxcoeff</span></code> <em>(0.5), &lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">REGULARIZATION</span> <span class="pre">VISMAX</span> <span class="pre">COEFF</span></code>]:</p>
<p>controls maximum artificial viscosity</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">c0</span></code> [<code class="docutils literal notranslate"><span class="pre">REGULARIZATION</span> <span class="pre">AVM</span> <span class="pre">C0</span></code>]:</p>
<p>if provided, make viscosity C0 continous across elements</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">rampconstant</span></code> <em>(1.0), &lt;float&gt;</em> [<code class="docutils literal notranslate"><span class="pre">REGULARIZATION</span> <span class="pre">RAMP</span> <span class="pre">CONSTANT</span></code>]:</p>
<p>controls ramp to maximum artificial viscosity</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="mesh-section">
<h3><code class="docutils literal notranslate"><span class="pre">MESH</span></code> section<a class="headerlink" href="#mesh-section" title="Link to this heading"></a></h3>
<p>This section is used to describe mesh settings and set up various mesh solvers
for mesh motion.</p>
<p><strong>partitioner</strong> [<code class="docutils literal notranslate"><span class="pre">MESH</span> <span class="pre">PARTITIONER</span></code>]</p>
<p><strong>solver</strong> <em>elasticity, none, user</em></p>
<p>If <code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">none</span></code>, the mesh does not move and [<code class="docutils literal notranslate"><span class="pre">MOVING</span> <span class="pre">MESH</span></code>] is set to false.
Otherwise, the solver is stored in [<code class="docutils literal notranslate"><span class="pre">MESH</span> <span class="pre">SOLVER</span></code>]. When <code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">user</span></code>, the
mesh moves according to a user-specified velocity. Alternatively, if
<code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">elasticity</span></code>, then the mesh motion is solved with an <a class="reference internal" href="glossary.html#term-ALE"><span class="xref std std-term">ALE</span></a> formulation.</p>
</section>
<section id="occa-section">
<h3><code class="docutils literal notranslate"><span class="pre">OCCA</span></code> section<a class="headerlink" href="#occa-section" title="Link to this heading"></a></h3>
<p>This section is used to specify the <a class="reference internal" href="glossary.html#term-OCCA"><span class="xref std std-term">OCCA</span></a> backend for parallelization.</p>
<p><strong>backend</strong> <em>(CUDA), CPU, HIP, OPENCL, OPENMP, SERIAL</em> [<code class="docutils literal notranslate"><span class="pre">THREAD</span> <span class="pre">MODEL</span></code>]</p>
<p>OCCA backend; <code class="docutils literal notranslate"><span class="pre">CPU</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">SERIAL</span></code>, and means that parallelism is achieved with
<a class="reference internal" href="glossary.html#term-MPI"><span class="xref std std-term">MPI</span></a>.</p>
<p><strong>deviceNumber</strong> <em>(LOCAL-RANK), &lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">DEVICE</span> <span class="pre">NUMBER</span></code>]</p>
</section>
<section id="pressure-section">
<h3><code class="docutils literal notranslate"><span class="pre">PRESSURE</span></code> section<a class="headerlink" href="#pressure-section" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">PRESSURE</span></code> section describes solve settings for the pressure equation. Note that
this block is only read if the <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code> block is also present.</p>
<p><strong>downwardSmoother</strong> <em>ASM, jacobi, RAS</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">MULTIGRID</span> <span class="pre">DOWNWARD</span> <span class="pre">SMOOTHER</span></code>]</p>
<p><strong>galerkinCoarseOperator</strong> <em>&lt;bool&gt;</em> [<code class="docutils literal notranslate"><span class="pre">GALERKIN</span> <span class="pre">COARSE</span> <span class="pre">OPERATOR</span></code>]</p>
<p><strong>maxIterations</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">MAXIMUM</span> <span class="pre">ITERATIONS</span></code>]</p>
<p><strong>pMultigridCoarsening</strong> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">MULTIGRID</span> <span class="pre">COARSENING</span></code>]</p>
<p><strong>preconditioner</strong> <em>jacobi, multigrid, none, semfem, semg</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">PRECONDITIONER</span></code>]</p>
<p>The pressure preconditioner to use; <code class="docutils literal notranslate"><span class="pre">semg</span></code> and <code class="docutils literal notranslate"><span class="pre">multigrid</span></code> both result
in a multigrid preconditioner.</p>
<p><strong>residualProj</strong> <em>(true), false</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span></code>]</p>
<p><strong>residualProjectionStart</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">START</span></code>]</p>
<p><strong>residualProjectionVectors</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">VECTORS</span></code>]</p>
<p><strong>residualTol</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">SOLVER</span> <span class="pre">TOLERANCE</span></code>]</p>
<p>Absolute residual tolerance for the pressure solution</p>
<p><strong>smootherType</strong> <em>additive, asm, chebyshev, chebyshev+ras, chebyshev+asm, ras</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">MULTIGRID</span> <span class="pre">SMOOTHER</span></code>]</p>
<p><strong>solver</strong></p>
<p><strong>upwardSmoother</strong> <em>ASM, JACOBI, RAS</em> [<code class="docutils literal notranslate"><span class="pre">PRESSURE</span> <span class="pre">MULTIGRID</span> <span class="pre">UPWARD</span> <span class="pre">SMOOTHER</span></code>]</p>
</section>
<section id="problemtype-section">
<h3><code class="docutils literal notranslate"><span class="pre">PROBLEMTYPE</span></code> section<a class="headerlink" href="#problemtype-section" title="Link to this heading"></a></h3>
<p>This section is used to control the form of the governing equations used in nekRS.
While individual equations can be turned on/off in the <code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code>, <code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code>,
and <code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code> sections, this block is used for higher-level control of the forms
of those equations themselves.</p>
<p><strong>equation</strong> <em>stokes</em></p>
<p>Whether to omit the advection term in the conservation of momentum equation, therefore
solving for the Stokes equations. If <code class="docutils literal notranslate"><span class="pre">equation</span> <span class="pre">=</span> <span class="pre">stokes</span></code>, then
[<code class="docutils literal notranslate"><span class="pre">ADVECTION</span></code>] is set to false.</p>
<p><strong>stressFormulation</strong> <em>(false), true</em> [<code class="docutils literal notranslate"><span class="pre">STRESSFORMULATION</span></code>]</p>
<p>Whether the viscosity (molecular plus turbulent) is not constant, therefore requiring
use of the full form of the viscous stress tensor <span class="math notranslate nohighlight">\(\tau\)</span>. By setting <code class="docutils literal notranslate"><span class="pre">stressFormulation</span> <span class="pre">=</span> <span class="pre">false</span></code>,
<span class="math notranslate nohighlight">\(\nabla\cdot\tau\)</span> is represented as <span class="math notranslate nohighlight">\(\nabla\cdot\tau=\mu\nabla^2\mathbf u\)</span>.
Even if the molecular viscosity is constant, this parameter must be set to <code class="docutils literal notranslate"><span class="pre">true</span></code>
when using a <a class="reference internal" href="glossary.html#term-RANS"><span class="xref std std-term">RANS</span></a> model because the turbulent viscosity portion of the overall
viscosity is not constant.</p>
</section>
<section id="scalarxx-section">
<h3><code class="docutils literal notranslate"><span class="pre">SCALARXX</span></code> section<a class="headerlink" href="#scalarxx-section" title="Link to this heading"></a></h3>
<p>This section is used to define the transport parameters and solver settings for each
passive scalar. For instance, in a simulation with two passive scalars, you would have
two sections - <code class="docutils literal notranslate"><span class="pre">SCALAR01</span></code> and <code class="docutils literal notranslate"><span class="pre">SCALAR02</span></code>, each of which represents a passive scalar.</p>
<p><strong>boundaryTypeMap</strong> <em>&lt;string[]&gt;</em></p>
<p>Array of strings describing the boundary condition to be applied to each sideset, ordered
by sideset ID. The valid characters/strings are shown in Table
<a class="reference internal" href="#scalar-bcs"><span class="std std-ref">Passive Scalar Boundary Conditions</span></a>.</p>
<p><strong>diffusivity</strong> <em>&lt;double&gt;</em></p>
<p>Although this is named <code class="docutils literal notranslate"><span class="pre">diffusivity</span></code>, this parameter doubly represents the conductivity
governing diffusion of the passive scalar. In other words, the analogue from the
<code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> section (a passive scalar in its internal representation) is the
<code class="docutils literal notranslate"><span class="pre">conductivity</span></code> parameter. If a negative value is provided, the
conductivity is internally set to <span class="math notranslate nohighlight">\(1/|k|\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the value of the
<code class="docutils literal notranslate"><span class="pre">conductivity</span></code> key. If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<p><strong>residualProjection</strong> <em>&lt;bool&gt;</em></p>
<p><strong>residualProjectionStart</strong> <em>&lt;int&gt;</em></p>
<p><strong>residualProjectionVectors</strong> <em>&lt;int&gt;</em></p>
<p><strong>residualTol</strong> <em>&lt;double&gt;</em></p>
<p>Absolute residual tolerance for the passive scalar solution</p>
<p><strong>rho</strong> <em>&lt;double&gt;</em></p>
<p>Although this is name <code class="docutils literal notranslate"><span class="pre">rho</span></code>, this parameter doubly represents the coefficient on the
total derivative of the passive scalar. In other words, the analogue from the
<code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> section (a passive scalar in its internal representation) is the
<code class="docutils literal notranslate"><span class="pre">rhoCp</span></code> parameter. If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
</section>
<section id="temperature-section">
<h3><code class="docutils literal notranslate"><span class="pre">TEMPERATURE</span></code> section<a class="headerlink" href="#temperature-section" title="Link to this heading"></a></h3>
<p>This section is used to define the transport parameters and solver settings for the
temperature passive scalar.</p>
<p><strong>boundaryTypeMap</strong> <em>&lt;string[]&gt;</em></p>
<p>Array of strings describing the boundary condition to be applied to each sideset, ordered
by sideset ID. The valid characters/strings are shown in Table
<a class="reference internal" href="#scalar-bcs"><span class="std std-ref">Passive Scalar Boundary Conditions</span></a>.</p>
<p><strong>conductivity</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">DIFFUSIVITY</span></code>]</p>
<p>Constant thermal conductivity; if a negative value is provided, the thermal conductivity
is internally set to <span class="math notranslate nohighlight">\(1/|k|\)</span>, where <span class="math notranslate nohighlight">\(k\)</span> is the value of the <code class="docutils literal notranslate"><span class="pre">conductivity</span></code>
key. If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<p><strong>residualProj</strong> <em>&lt;bool&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span></code>]</p>
<p><strong>residualProjectionStart</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">START</span></code>]</p>
<p><strong>residualProjectionVectors</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">VECTORS</span></code>]</p>
<p><strong>residualTol</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">SOLVER</span> <span class="pre">TOLERANCE</span></code>]</p>
<p><strong>rhoCp</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">SCALAR00</span> <span class="pre">DENSITY</span></code>]</p>
<p>Constant volumetric isobaric specific heat. If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<p><strong>solver</strong> <em>none</em></p>
<p>You can turn off the solution of temperature by setting the solver to <code class="docutils literal notranslate"><span class="pre">none</span></code>.</p>
</section>
<section id="velocity-section">
<h3><code class="docutils literal notranslate"><span class="pre">VELOCITY</span></code> section<a class="headerlink" href="#velocity-section" title="Link to this heading"></a></h3>
<p>This section is used to define the transport properties and solver settings for the
velocity.</p>
<p><strong>boundaryTypeMap</strong> <em>&lt;string[]&gt;</em></p>
<p>Array of strings describing the boundary condition to be applied to each sideset, ordered
by sideset ID. The valid characters/strings are shown in Table
<a class="reference internal" href="#flow-bcs"><span class="std std-ref">Flow Boundary Conditions</span></a>. Note that no boundary conditions need to be
specified in the <code class="docutils literal notranslate"><span class="pre">PRESSURE</span></code> section, since the form of the pressure conditions are
specified in tandem with the velocity conditions with this parameter.</p>
<p><strong>density</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">DENSITY</span></code>]</p>
<p>Constant fluid density. If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
<p><strong>maxIterations</strong> <em>(200), &lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">MAXIMUM</span> <span class="pre">ITERATIONS</span></code>]</p>
<p>Maximum number of iterations for the velocity solve</p>
<p><strong>residualProj</strong> <em>&lt;bool&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span></code>]</p>
<p><strong>residualProjectionStart</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">START</span></code>]</p>
<p><strong>residualProjectionVectors</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">RESIDUAL</span> <span class="pre">PROJECTION</span> <span class="pre">VECTORS</span></code>]</p>
<p><strong>residualTol</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">SOLVER</span> <span class="pre">TOLERANCE</span></code>]</p>
<p>Absolute tolerance used for the velocity solve.</p>
<p><strong>solver</strong> <em>none</em> [<code class="docutils literal notranslate"><span class="pre">VELOCITY</span> <span class="pre">SOLVER</span></code>]</p>
<p>You can turn off the solution of the flow (velocity and pressure) by setting the solver
to <code class="docutils literal notranslate"><span class="pre">none</span></code>. Otherwise, if you omit <code class="docutils literal notranslate"><span class="pre">solver</span></code> entirely, the velocity solve will be turned on.
If you turn the velocity solve off, then you automatically also turn off the pressure solve.</p>
<p><strong>viscosity</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">VISCOSITY</span></code>]</p>
<p>Constant dynamic viscosity; if a negative value is provided, the dynamic viscosity is
internally set to <span class="math notranslate nohighlight">\(1/|\mu|\)</span>, where <span class="math notranslate nohighlight">\(\mu\)</span> is the value of the <code class="docutils literal notranslate"><span class="pre">viscosity</span></code> key.
If not specified, this defaults to <span class="math notranslate nohighlight">\(1.0\)</span>.</p>
</section>
<section id="casedata-section">
<h3><code class="docutils literal notranslate"><span class="pre">CASEDATA</span></code> section<a class="headerlink" href="#casedata-section" title="Link to this heading"></a></h3>
<p>This section may be used to provide custom parameters in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file that are to be read
in the <code class="docutils literal notranslate"><span class="pre">.udf</span></code> file. For example, you may specify</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[CASEDATA]</span>
<span class="w">  </span><span class="na">Re_tau</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">550</span>
</pre></div>
</div>
<p>in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file; the parameters should be read in the <a class="reference internal" href="#udf-setup0"><span class="std std-ref">UDF_Setup0</span></a>
function, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">dfloat</span><span class="w"> </span><span class="n">Re_tau</span><span class="p">;</span>
<span class="n">platform</span><span class="o">-&gt;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">extract</span><span class="p">(</span><span class="s">&quot;casedata&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;re_tau&quot;</span><span class="p">,</span><span class="n">Re_tau</span><span class="p">);</span>
</pre></div>
</div>
<p>NekRS does not check the contents of the <code class="docutils literal notranslate"><span class="pre">CASEDATA</span></code> section; such checks may be added in the
<code class="docutils literal notranslate"><span class="pre">UDF_Setup0</span></code> function as well.</p>
</section>
<section id="deprecated-parameters">
<h3>Deprecated parameters<a class="headerlink" href="#deprecated-parameters" title="Link to this heading"></a></h3>
<section id="id2">
<h4><code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<ul>
<li><p><strong>filterCutoffRatio</strong> <em>&lt;double&gt;</em> [deprecated, see <strong>regularization</strong>]</p>
</li>
<li><p><strong>filtering</strong> <em>hpfrt</em> [deprecated, see <strong>regularization</strong>]</p>
<p>If <code class="docutils literal notranslate"><span class="pre">filtering</span> <span class="pre">=</span> <span class="pre">hpfrt</span></code>, [<code class="docutils literal notranslate"><span class="pre">FILTER</span> <span class="pre">STABILIZATION</span></code>] is set to <code class="docutils literal notranslate"><span class="pre">RELAXATION</span></code>,
and <code class="docutils literal notranslate"><span class="pre">filterWeight</span></code> must be specified. If <code class="docutils literal notranslate"><span class="pre">filtering</span></code> is not specified,
[<code class="docutils literal notranslate"><span class="pre">FILTER</span> <span class="pre">STABILIZATION</span></code>] is set to <code class="docutils literal notranslate"><span class="pre">NONE</span></code> by default.</p>
</li>
<li><p><strong>filterModes</strong> <em>&lt;int&gt;</em> [<code class="docutils literal notranslate"><span class="pre">HPFRT</span> <span class="pre">MODES</span></code>] [deprecated, see <strong>regularization</strong>]</p></li>
</ul>
<blockquote>
<div><p>Number of filter modes; minimum value is 1. If not specified, the number of modes
is set by default to the nearest integer to <span class="math notranslate nohighlight">\((N+1)(1-f_c)\)</span>, where <span class="math notranslate nohighlight">\(f_c\)</span>
is the filter cutoff ratio.</p>
</div></blockquote>
<ul class="simple">
<li><p><strong>filterWeight</strong> <em>&lt;double&gt;</em> [<code class="docutils literal notranslate"><span class="pre">HPFRT</span> <span class="pre">STRENGTH</span></code>] [deprecated, see <strong>regularization</strong>]</p></li>
</ul>
<blockquote>
<div></div></blockquote>
</section>
</section>
<section id="legacy-option-rea">
<h3>Legacy Option (.rea)<a class="headerlink" href="#legacy-option-rea" title="Link to this heading"></a></h3>
<p>An alternative to the use of the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file is to use the legacy Nek5000-based <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file
to set up the case parameters.
See the <code class="docutils literal notranslate"><span class="pre">Mesh</span> <span class="pre">File</span> <span class="pre">(.re2)</span></code> section of the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a>
<a class="reference external" href="http://nek5000.github.io/NekDoc/problem_setup/case_files.html">documentation</a> <a class="footnote-reference brackets" href="#f1" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
for further details on the format for the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file contains both simulation parameters (now covered by the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file) as well
as mesh information (now covered by the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> file). This section
here only describes the legacy approach to setting simulation parameters via the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file.</p>
</section>
</section>
<section id="mesh-file-re2">
<h2>Mesh File (.re2)<a class="headerlink" href="#mesh-file-re2" title="Link to this heading"></a></h2>
<p>The nekRS mesh file is provided in a binary format with a nekRS-specific
<code class="docutils literal notranslate"><span class="pre">.re2</span></code> extension. This format can be produced by either:</p>
<ul class="simple">
<li><p>Converting a mesh made with commercial meshing software to <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format, or</p></li>
<li><p>Directly creating an <code class="docutils literal notranslate"><span class="pre">.re2</span></code>-format mesh with nekRS-specific scripts</p></li>
</ul>
<p>There are three main limitations for the nekRS mesh:</p>
<ul class="simple">
<li><p>nekRS is restricted to 3-D hexahedral meshes.</p></li>
<li><p>The numeric IDs for the mesh boundaries must be ordered contiguously beginning from 1.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format only supports HEX8 and HEX 20 (eight- and twenty-node) hexahedral elements.</p></li>
</ul>
<p>Lower-dimensional problems can be accommodated on these 3-D meshes by applying zero gradient
boundary conditions to all solution variables in directions perpendicular to the
simulation plane or line, respectively. All source terms and material properties in the
governing equations must therefore also be fixed in the off-interest directions.</p>
<p>For cases with conjugate heat transfer, nekRS uses an archaic process
for differentiating between fluid and solid regions. Rather than block-restricting variables to
particular regions of the same mesh, nekRS retains two independent mesh representations
for the same problem. One of these meshes represents the flow domain, while the other
represents the heat transfer domain. The <code class="docutils literal notranslate"><span class="pre">nrs_t</span></code> struct, which encapsulates all of
the nekRS simulation data related to the flow solution, represents the flow mesh as
<code class="docutils literal notranslate"><span class="pre">nrs_t.mesh</span></code>. Similarly,
the <code class="docutils literal notranslate"><span class="pre">cds_t</span></code> struct, which encapsulates all of the nekRS simulation data related to the
convection-diffusion passive scalar solution, has one mesh for each passive scalar. That is,
<code class="docutils literal notranslate"><span class="pre">cds_t.mesh[0]</span></code> is the mesh for the first passive scalar, <code class="docutils literal notranslate"><span class="pre">cds_t.mesh[1]</span></code> is the mesh
for the second passive scalar, and so on.
Note that only the temperature passive scalar uses the conjugate heat transfer mesh,
even though the <code class="docutils literal notranslate"><span class="pre">cds_t</span></code> struct encapsulates information related to all other
passive scalars (such as chemical concentration, or turbulent kinetic energy). All
non-temperature scalars are only solved on the flow mesh.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When writing user-defined functions that rely on mesh information (such as boundary
IDs and spatial coordinates), you must take care to use the correct mesh representation
for your problem. For instance, to apply initial conditions to a flow variable, you
would need to loop over the number of quadrature points known on the <code class="docutils literal notranslate"><span class="pre">nrs_t</span></code> meshes,
rather than the <code class="docutils literal notranslate"><span class="pre">cds_t</span></code> meshes for the passive scalars (unless the meshes are the same,
such as if you have heat transfer in a fluid-only domain).
Also note that the <code class="docutils literal notranslate"><span class="pre">cds_t</span> <span class="pre">*</span> <span class="pre">cds</span></code> object will not exist if your problem
does not have any passive scalars.</p>
</div>
<p>nekRS requires that the flow mesh be a subset of the heat transfer mesh. In other words,
the flow mesh always has less than (or equal to, for cases without conjugate heat transfer)
the number of elements in the heat transfer mesh. Creating a mesh for conjugate heat
transfer problems requires additional pre-processing steps that are described in the
<a class="reference internal" href="detailed_usage.html#cht-mesh"><span class="std std-ref">Creating a Mesh for Conjugate Heat Tranfser</span></a> section. The remainder
of this section describes how to generate a mesh in <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format, assuming
any pre-processing steps have been done for the special cases of conjugate heat transfer.</p>
<section id="converting-an-existing-commercial-mesh">
<h3>Converting an Existing Commercial Mesh<a class="headerlink" href="#converting-an-existing-commercial-mesh" title="Link to this heading"></a></h3>
<p>The most general and flexible approach for creating a mesh is to use commercial meshing software
such as Cubit or Gmsh. After creating the mesh, it must be converted to the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> binary format. Depending
on the mesh format (such as Exodus II format or Gmsh format), a conversion script is used to
convert the mesh to <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format. See the
<a class="reference internal" href="detailed_usage.html#converting-mesh"><span class="std std-ref">Converting a Mesh to .re2 Format</span></a> section for examples demonstrating
conversion of Exodus and Gmsh meshes into <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format.</p>
</section>
<section id="nek5000-script-based-meshing">
<span id="nek5000-mesh"></span><h3>Nek5000 Script-Based Meshing<a class="headerlink" href="#nek5000-script-based-meshing" title="Link to this heading"></a></h3>
<p>A number of meshing scripts ship with the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a> dependency, which allow
you to directly create <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format meshes without the need of commercial meshing
tools. These scripts, such as <code class="docutils literal notranslate"><span class="pre">genbox</span></code>, take user input related to the desired
grid spacing to generate meshes for fairly simple geometries. Please consult the
<a class="reference external" href="http://nek5000.github.io/NekDoc/index.html">Nek5000 documentation</a>
for more information on the use of these scripts.</p>
</section>
<section id="id4">
<h3>Legacy Option (.rea)<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>An alternative to the use of the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> mesh file is to use the legacy Nek5000-based <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file
to set up the mesh.
See the <code class="docutils literal notranslate"><span class="pre">Mesh</span> <span class="pre">File</span> <span class="pre">(.re2)</span></code> section of the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a>
<a class="reference external" href="http://nek5000.github.io/NekDoc/problem_setup/case_files.html">documentation</a> <a class="footnote-reference brackets" href="#f1" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
for further details on the format for the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file contains both simulation parameters (now covered by the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file) as well as
mesh information (now covered by the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> file). This section
here only describes the legacy approach to setting mesh information via the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file.</p>
<p>The mesh section of the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file can be generated in two different manners -
either by specifying all the element nodes by hand, or with the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a> mesh
generation scripts introduced in Section <a class="reference internal" href="#nek5000-mesh"><span class="std std-ref">Nek5000 Script-Based Meshing</span></a>.
Because the binary <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format is preferred for very large meshes where memory may be
a concern, the <code class="docutils literal notranslate"><span class="pre">.rea</span></code> file approach is considered to be a legacy option.
The mesh portion of the legacy <code class="docutils literal notranslate"><span class="pre">.rea</span></code>
file can be converted to the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format with the <code class="docutils literal notranslate"><span class="pre">reatore2</span></code> script, which also
ships with the <a class="reference internal" href="glossary.html#term-Nek5000"><span class="xref std std-term">Nek5000</span></a> dependency.</p>
</section>
</section>
<section id="user-defined-host-functions-udf">
<span id="udf-functions"></span><h2>User-Defined Host Functions (.udf)<a class="headerlink" href="#user-defined-host-functions-udf" title="Link to this heading"></a></h2>
<p>User-defined functions for the host are specified in the <code class="docutils literal notranslate"><span class="pre">.udf</span></code> file. These
functions can be used to perform virtually any action that can be programmed in C++.
Some of the more common examples are setting initial conditions, querying the solution
at regular intervals, and defining custom material properties and source terms. The
available functions that you may define in the <code class="docutils literal notranslate"><span class="pre">.udf</span></code> file are as follows. From the
examples shown on the <a class="reference internal" href="detailed_usage.html#detailed"><span class="std std-ref">Detailed Usage</span></a> page, you will see that usage
of these functions requires some proficiency in the C++
language as well as some knowledge of the nekRS source code internals.</p>
<section id="udf-executestep-nrs-t-nrs-dfloat-time-int-tstep">
<h3><code class="docutils literal notranslate"><span class="pre">UDF_ExecuteStep(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">dfloat</span> <span class="pre">time,</span> <span class="pre">int</span> <span class="pre">tstep)</span></code><a class="headerlink" href="#udf-executestep-nrs-t-nrs-dfloat-time-int-tstep" title="Link to this heading"></a></h3>
<p>This user-defined function is probably the most flexible of the nekRS user-defined
functions. This function is called once at the start of the simulation just before
beginning the time stepping, and then once per time step after running each step.</p>
</section>
<section id="udf-loadkernels-nrs-t-nrs">
<h3><code class="docutils literal notranslate"><span class="pre">UDF_LoadKernels(nrs_t*</span>&#160; <span class="pre">nrs)</span></code><a class="headerlink" href="#udf-loadkernels-nrs-t-nrs" title="Link to this heading"></a></h3>
<p>This user-defined function is used to load case-specific device kernels that are
used in other UDF functions. For instance, if you add a custom forcing term to the
momentum equations, you need to tell nekRS to compile that kernel by loading it in
this function. The custom material property example shown in the
<a class="reference internal" href="detailed_usage.html#custom-properties"><span class="std std-ref">Setting Custom Properties with UDF_Setup</span></a> section
demonstrates how to load kernels with this function. The process is quite simple,
and only involves:</p>
<ul class="simple">
<li><p>Declaring all kernels as <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">occa::kernel</span></code> at the top of the <code class="docutils literal notranslate"><span class="pre">.udf</span></code> file</p></li>
<li><p>Loading those kernels in <code class="docutils literal notranslate"><span class="pre">UDF_LoadKernels</span></code></p></li>
<li><p>Defining those kernels in the device user file (the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> file)</p></li>
</ul>
<p>The only kernels in the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> file that don’t need to be explicitly loaded are
the boundary condition kernels that ship with nekRS. During the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> just-in-time
compilation, nekRS will search the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> file for any functions that match the
nekRS boundary condition functions, and automatically create and load a kernel based
on the function internals set by the user. For instance, in the <code class="docutils literal notranslate"><span class="pre">setOUDF</span></code> function
in the nekRS source code,
the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> file is scanned for a string matching <code class="docutils literal notranslate"><span class="pre">scalarDirichletConditions</span></code> (one
of the boundary condition functions in Table <a class="reference internal" href="#scalar-bcs"><span class="std std-ref">Passive Scalar Boundary Conditions</span></a>).
If this string is found, then the function internals written by the user are cast
into a generic <a class="reference internal" href="glossary.html#term-OCCA"><span class="xref std std-term">OCCA</span></a> kernel that is then written into a just-in-time compiled
<a class="reference internal" href="glossary.html#term-OKL"><span class="xref std std-term">OKL</span></a>-language file at <code class="docutils literal notranslate"><span class="pre">.cache/udf/udf.okl</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">str</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;void scalarDirichletConditions&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
<span class="w">  </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;void scalarDirichletConditions(bcData *bc){}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">  </span><span class="s">&quot;@kernel void __dummy__(int N) {&quot;</span>
<span class="w">  </span><span class="s">&quot;  for (int i = 0; i &lt; N; ++i; @tile(16, @outer, @inner)) {}&quot;</span>
<span class="w">  </span><span class="s">&quot;}&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">UDF_LoadKernels</span></code> function is passed the nekRS simulation object <code class="docutils literal notranslate"><span class="pre">nrs</span></code> to provide optional
access to the <code class="docutils literal notranslate"><span class="pre">occa::properties</span></code> object on the <code class="docutils literal notranslate"><span class="pre">nrs-&gt;kernelInfo</span></code> object. In
addition to loading kernels, this function can also be used to propagate user-defined
variables to the kernels. See
the <a class="reference internal" href="detailed_usage.html#defining-variables-for-device"><span class="std std-ref">Defining Variables to Access in Device Kernels</span></a>
section for a description of this feature.</p>
</section>
<section id="udf-setup0-mpi-comm-comm-setupaide-options">
<span id="udf-setup0"></span><h3><code class="docutils literal notranslate"><span class="pre">UDF_Setup0(MPI_Comm</span> <span class="pre">comm,</span> <span class="pre">setupAide</span> <span class="pre">&amp;</span> <span class="pre">options)</span></code><a class="headerlink" href="#udf-setup0-mpi-comm-comm-setupaide-options" title="Link to this heading"></a></h3>
<p>This user-defined function is passed the nekRS <a class="reference internal" href="glossary.html#term-MPI"><span class="xref std std-term">MPI</span></a> communicator <code class="docutils literal notranslate"><span class="pre">comm</span></code> and a data
structure containing all of the user-specified simulation options, <code class="docutils literal notranslate"><span class="pre">options</span></code>. This function is
called once at the beginning of the simulation <em>before</em> initializing the nekRS internals
such as the mesh, solvers, and solution data arrays. Because virtually no aspects of
the nekRS simulation have been initialized at the point when this function is called,
this function is primarily used to modify the user settings. For the typical user,
all relevant settings are already exposed through the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file; any desired
changes to settings should therefore be performed by modifying the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file.</p>
<p>This function is intended for developers or advanced users to overwrite any user
settings that may not be exposed to the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file. For instance, setting
<code class="docutils literal notranslate"><span class="pre">timeStepper</span> <span class="pre">=</span> <span class="pre">tombo2</span></code> in the <code class="docutils literal notranslate"><span class="pre">GENERAL</span></code> section triggers a number of other internal
settings in nekRS that do not need to be exposed to the typical user, but that perhaps
a developer may want to modify for testing purposes.</p>
</section>
<section id="udf-setup-nrs-t-nrs">
<h3><code class="docutils literal notranslate"><span class="pre">UDF_Setup(nrs_t*</span> <span class="pre">nrs)</span></code><a class="headerlink" href="#udf-setup-nrs-t-nrs" title="Link to this heading"></a></h3>
<p>This user-defined function is passed the nekRS simulation object <code class="docutils literal notranslate"><span class="pre">nrs</span></code>. This function
is called once at the beginning of the simulation <em>after</em> initializing the mesh, solution
arrays, material property arrays, and boundary field mappings. This function is most
commonly used to:</p>
<ul class="simple">
<li><p>Apply initial conditions to the solution</p></li>
<li><p>Assign function pointers to user-defined source terms and material properties</p></li>
</ul>
<p>Any other additional setup actions that depend on initialization of the solution arrays
and mesh can of course also be placed in this function.</p>
</section>
<section id="other-functions-for-custom-sources-on-the-udf-structure">
<h3>Other Functions for Custom Sources on the <code class="docutils literal notranslate"><span class="pre">udf</span></code> Structure<a class="headerlink" href="#other-functions-for-custom-sources-on-the-udf-structure" title="Link to this heading"></a></h3>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">UDF_Setup0</span></code>, <code class="docutils literal notranslate"><span class="pre">UDF_Setup</span></code>, <code class="docutils literal notranslate"><span class="pre">UDF_ExecuteStep</span></code>, and <code class="docutils literal notranslate"><span class="pre">UDF_LoadKernels</span></code>,
there are other user-defined functions. These functions
are handled in a slightly different manner - rather than be tied to a specific function name
like <code class="docutils literal notranslate"><span class="pre">UDF_Setup0</span></code>, these functions are provided in terms of generic function pointers to
<em>any</em> function (provided the function parameters match those of the pointer). The four
function pointers are named as follows in nekRS:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Function pointer</p></th>
<th class="head"><p>Function signature</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">udf.converged</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">int</span> <span class="pre">stage)</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">udf.uEqnSource</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">float</span> <span class="pre">t,</span> <span class="pre">m</span> <span class="pre">o_U,</span> <span class="pre">m</span> <span class="pre">o_FU)</span></code></p></td>
<td><p>momentum source</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">udf.sEqnSource</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">float</span> <span class="pre">t,</span> <span class="pre">m</span> <span class="pre">o_S,</span> <span class="pre">m</span> <span class="pre">o_SU)</span></code></p></td>
<td><p>scalar source</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">udf.properties</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">float</span> <span class="pre">t,</span> <span class="pre">m</span> <span class="pre">o_U,</span> <span class="pre">m</span> <span class="pre">o_S,</span> <span class="pre">m</span> <span class="pre">o_Up,</span> <span class="pre">m</span> <span class="pre">o_Sp)</span></code></p></td>
<td><p>material properties</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">udf.div</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f(nrs_t*</span> <span class="pre">nrs,</span> <span class="pre">float</span> <span class="pre">t,</span> <span class="pre">m</span> <span class="pre">o_div)</span></code></p></td>
<td><p>thermal divergence</p></td>
</tr>
</tbody>
</table>
<p>To shorten the syntax above, the type <code class="docutils literal notranslate"><span class="pre">m</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">occa::memory</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code> is the
name of the function, which can be <em>any</em> user-defined name. Other parameters that appear in the
function signatures are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nrs</span></code> is a pointer to the nekRS simulation object</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stage</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> is the current simulation time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_U</span></code> is the velocity solution on the device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_S</span></code> is the scalar solution on the device</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_FU</span></code> is the forcing term in the momentum equation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_SU</span></code> is the forcing term in the scalar equation(s)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_Up</span></code> is the material properties (<span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\rho\)</span>) for the momentum equation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_Sp</span></code> is the material properties (<span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(\rho C_p\)</span>) for the scalar equation(s)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">o_div</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">udf.uEqnSource</span></code> allows specification of a momentum source, such as a gravitational force, or
a friction form loss. The <code class="docutils literal notranslate"><span class="pre">udf.sEqnSource</span></code> allows specification of a source term for the passive
scalars. For a temperature passive scalar, this source term might represent a volumetric heat source,
while for a chemical concentration passive scalar, this source term could represent a mass
source. See the <a class="reference internal" href="detailed_usage.html#custom-sources"><span class="std std-ref">Setting Custom Source Terms</span></a> section for an example
of setting custom source terms.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">udf.properties</span></code> allows specification of custom material properties for the flow
and passive scalar equations,
which can be a function of the solution as well as position and time. See the
<a class="reference internal" href="detailed_usage.html#custom-properties"><span class="std std-ref">Setting Custom Properties</span></a> section for an example of setting custom
properties.</p>
<p>Finally, <code class="docutils literal notranslate"><span class="pre">udf.div</span></code>
allows specification of the thermal divergence term needed for the low Mach formulation.</p>
</section>
<section id="legacy-option-usr">
<h3>Legacy Option (.usr)<a class="headerlink" href="#legacy-option-usr" title="Link to this heading"></a></h3>
<p>The legacy alternative to user-defined functions in the <code class="docutils literal notranslate"><span class="pre">.udf</span></code> file is to write
Fortran routines in a <code class="docutils literal notranslate"><span class="pre">.usr</span></code> file based on Nek5000 code internals.</p>
</section>
</section>
<section id="user-defined-device-functions-oudf">
<span id="oudf-functions"></span><h2>User-Defined Device Functions (.oudf)<a class="headerlink" href="#user-defined-device-functions-oudf" title="Link to this heading"></a></h2>
<p>This file contains all user-defined functions that are to run on the device. These functions include
all functions used to apply boundary conditions that are built in to nekRS, as well as any other
problem-specific device functions.</p>
<section id="boundary-condition-functions">
<h3>Boundary Condition Functions<a class="headerlink" href="#boundary-condition-functions" title="Link to this heading"></a></h3>
<p>The type of condition to apply for each boundary is specified by the <code class="docutils literal notranslate"><span class="pre">boundaryTypeMap</span></code> parameter
in the <code class="docutils literal notranslate"><span class="pre">.par</span></code> file. A character or longer-form word is used to indicate each boundary condition, where the
entries in <code class="docutils literal notranslate"><span class="pre">boundaryTypeMap</span></code> are listed in increasing boundary ID order.
However, this single line only specifies the <em>type</em> of boundary condition.
If that boundary condition requires additional information, such as a value to impose for
a Dirichlet velocity condition, or a flux to impose for a Neumann temperature condition, then
a device function must be provided in the <code class="docutils literal notranslate"><span class="pre">.oudf</span></code> file. A list of all possible boundary
conditions is as follows. For boundary conditions that require additional input from the user,
a device function is also listed. For other boundary conditions that are fully specified simply
by the type of condition (such as a wall boundary condition for velocity, which sets all
three components of velocity to zero without additional user input), no device function is
needed to apply that condition.</p>
<span id="flow-bcs"></span><table class="docutils align-default" id="id6">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Flow Boundary Conditions</span><a class="headerlink" href="#id6" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Character Map</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pressureDirichletConditions(bcData*</span> <span class="pre">bc)</span></code></p></td>
<td></td>
<td><p>Dirichlet pressure condition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">velocityDirichletConditions(bcData*</span> <span class="pre">bc)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">inlet</span></code></p></td>
<td><p>Dirichlet velocity condition</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">velocityNeumannConditions(bcData*</span> <span class="pre">bc)</span></code></p></td>
<td></td>
<td><p>Neumann velocity condition</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p>Periodic</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">w</span></code>, <code class="docutils literal notranslate"><span class="pre">wall</span></code></p></td>
<td><p>No-slip wall for velocity</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o</span></code>, <code class="docutils literal notranslate"><span class="pre">outlet</span></code>, <code class="docutils literal notranslate"><span class="pre">outflow</span></code></p></td>
<td><p>Zero-gradient velocity</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">slipx</span></code></p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">slipy</span></code></p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">slipz</span></code></p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">symx</span></code></p></td>
<td><p>?</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">symy</span></code></p></td>
<td><p>?</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">symz</span></code></p></td>
<td><p>?</p></td>
</tr>
</tbody>
</table>
<span id="scalar-bcs"></span><table class="docutils align-default" id="id7">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Passive Scalar Boundary Conditions</span><a class="headerlink" href="#id7" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Character Map</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scalarDirichletConditions(bcData*</span> <span class="pre">bc)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">inlet</span></code></p></td>
<td><p>Dirichlet condition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">scalarNeumannConditions(bcData*</span> <span class="pre">bc)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">flux</span></code></p></td>
<td><p>Neumann condition</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">p</span></code></p></td>
<td><p>Periodic</p></td>
</tr>
<tr class="row-odd"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">zeroflux</span></code></p></td>
<td><p>Zero-gradient</p></td>
</tr>
<tr class="row-even"><td><p>N/A</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o</span></code>, <code class="docutils literal notranslate"><span class="pre">outlet</span></code>, <code class="docutils literal notranslate"><span class="pre">outflow</span></code></p></td>
<td><p>Zero-gradient</p></td>
</tr>
</tbody>
</table>
<p>Each function has the same signature, and takes as input the <code class="docutils literal notranslate"><span class="pre">bc</span></code> object. This object contains
all information needed to apply a boundary condition - the position, unit normals, and solution
components. The “character map” refers to the character in the <code class="docutils literal notranslate"><span class="pre">boundaryTypeMap</span></code> key in the
<code class="docutils literal notranslate"><span class="pre">.par</span></code> file that will trigger this boundary condition. The character map can either be a single
letter, or a more verbose (and equivalent) string.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">scalar</span></code>-type boundary conditions
are called for boundary conditions on passive scalars, while the <code class="docutils literal notranslate"><span class="pre">pressure</span></code>- and <code class="docutils literal notranslate"><span class="pre">velocity</span></code>-type
conditions are called for the boundary conditions on the flow.</p>
<p>Each of these functions is <em>only</em> called on boundaries that contain that boundary. For instance,
if only boundaries 3 and 4 are primitive conditions on velocity, then <code class="docutils literal notranslate"><span class="pre">velocityDirichletConditions</span></code>
is only called on boundaries 3 and 4. See the <a class="reference internal" href="detailed_usage.html#boundary-conditions"><span class="std std-ref">Setting Boundary Conditions</span></a>
section for several examples on how to set boundary conditions with device functions.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id5">2</a>)</span>
<p>While the heading for <code class="docutils literal notranslate"><span class="pre">Mesh</span> <span class="pre">File</span> <span class="pre">(.re2)</span></code> seems to suggest that the contents refer only to the <code class="docutils literal notranslate"><span class="pre">.re2</span></code> format, the actual text description still points to the legacy <code class="docutils literal notranslate"><span class="pre">.rea</span></code> format.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="theory.html" class="btn btn-neutral float-left" title="Theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="commonly_used_variables.html" class="btn btn-neutral float-right" title="Commonly-Used Variables in nekRS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Huanxia Wei.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>